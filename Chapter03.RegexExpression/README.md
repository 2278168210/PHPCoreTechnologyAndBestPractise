##相关知识点总结
***
###正则表达式
---
* PHP中的正则表达式包含两种：
 + PCRE(Perl Compatible Regular Expression)，其函数以preg为前缀，为兼容Perl的正则表达式库
 + POSIX提供的函数，以ereg为前缀，PHP5.3后不再推荐使用，使用ereg系列函数会报有Deprecated级别错误
* PHP中的正则表达式包含三个部分：
 + 分隔符：除了字母、数字、反斜线和空白字符以外的任何字符均可作为分隔符，常用的有正斜线(/)，hash符号(#)以及取反符号(~)
 + 表达式：由一些特殊字符组成的字符串，用于进行字符串匹配
 + 修饰符：用于开启或者关系某种功能/模式
  
###元字符(Meta-Characters)
---
* 一般的英文字符会导致完全匹配
* 元字符包含的内容如下（不完整）
 + . 匹配除换行符以外的任意字符
 + \w 匹配字母或数字或下划线或汉字
 + \W [^\w]
 + \s 匹配任意空白符
 + \S [^\s]
 + \d 匹配数字，[0-9]
 + \D [^\d], [^0-9]
 + \b 匹配单词的开始或结束
 + \B [^\b]
 + ^ 字符串的开始
 + $ 字符串的结束
 + - 表示范围
 + [] 字符组，匹配其中任意一个
 + () 组，在组中^$表行首行尾
 + * 重复 >= 0次
 + + 重复 >= 1次
 + ? 重复 <= 1次
 + {n} 重复n次
 + {n,} 重复n次或更多次
 + {n,m} 重复n到m次
  
###正则表达式匹配规则
---
* 转义
 + 使用\进行转义；也可以使用\Q\E，其间的字符不被认为是元字符，而被视为普通字符  
   例：\(?0\d{2,3}[)-]?\d{8}可以匹配几种电话号码
 + 字符组内的量词元字符无需转义，无法匹配的{},[],()也无需转义
* 反义
 + 一般字符的反义使用^，而已知元字符的反义使用大写，如\d的反义即为\D
 + 用在开始位置的^表示字符串起始，而用于反义的^只能出现在字符组中
 + 不要随意使用反义，因为反义会扩大匹配范围，正则中尽量使用精确的匹配模式
* 分支
 + 使用|进行分支匹配，例如(a|to)t可以匹配at和tot，字符组[]可以看做是单个字符的分支匹配
 + 字符组的效率高于|分支，单个字符匹配时应尽量选择字符组
 + (exp)会导致文本捕获，如果不需要捕获则使用(?:exp)
 + 匹配分支条件时，从左到右测试，当遇到满足分支时则停止，故子分支需要放在较前的位置
* 分组
 + ()即是组的概念，组也可以重复多次，并且组会导致文本捕获
 + 使用组捕获的文本会被自动标记在对应的分组号中，从1开始依次增加
 + 可以使用(?<name>exp)或(?`name`exp)使当前组拥有自定义的组号
 + 可以使用(?:exp)剥夺一个组的组号分配参与权，即当前组文本不会被捕获
 + 零宽断言：(?=exp)匹配exp前面的位置、(?<=exp)匹配exp后面的位置、(?!exp)匹配后面不是exp的位置、(?<!exp)匹配前面不是exp的位置
 + (?#comment)提供注释辅助阅读，不影响正则表达式
* 反向引用
 + 使用分组匹配的文本可以被反向引用
 + 未命名分组的引用使用\1、\2……，其中\1表示的是匹配到的文本，而非正则表达式本身
 + 自定义组号的分组引用使用\k<name>的方式，例如\b(?<Word>\w+)\b\s+\k<Word>\b的效果与\b(\w+)\b\s+\1\b的效果相同
 + 例如引号匹配需要一致性，可以使用如下方式匹配引号内的文本^(?<Quote>"|').*?\k<Quote>$
* 环视
 + 环视即断言匹配，断言匹配匹配一个事实，而非内容
 + (?=exp) 称为零宽度正预测先行断言，又称顺序肯定环视，断言自身出现位置的后面能匹配表达式exp
 + (?<=exp) 称为零宽度回顾后发断言，又称逆序肯定环视，断言自身出现位置的前面能匹配表达式exp
 + 例：匹配HTML内容中被标签\<p\>或\<a\>包裹的内容的表达式为 (?=<[p|a]>).*(?<=<\/\1>)
 + (?!exp) 称为零宽度负预测先行断言，又称顺序否定环视，断言自身出现位置的后面不能匹配表达式exp
 + (?<!exp) 称为零宽度回顾后发断言，又称逆序否定环视，断言自身出现位置的前面不能匹配表达式exp
 + 例：匹配不包含简单HTML标签的内容表达式为 (?<!<\w>).*(?!<\/\1>)
* 贪婪/惰性匹配
 + 在默认匹配中，*+{}等量词的匹配总会尽可能多的匹配字符，这称为贪婪匹配
 + 在量词的后面加上一个?表示惰性匹配，即尽可能少的匹配字符
 + 贪婪匹配在匹配成功后会记录位置，然后向后匹配直到失败时回溯，故效率较低，适时使用惰性匹配可以提升效率

###
